<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="generator" content="Hugo 0.66.0" />
  <!-- <meta name="viewport" content="width=device-width, initial-scale=1"> -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- 引入Bootstrap CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">

  <!-- 引入jQuery -->
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>

  <!-- 引入Bootstrap JS -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.min.js"></script>

  <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,600" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
  <link rel="stylesheet" href="../css/normalize.css">
  <link rel="stylesheet" href="../css/skeleton.css">
  <link rel="stylesheet" href="../css/custom.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"
    integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
  <link rel="alternate" href="index.xml" type="application/rss+xml">
  <link rel="shortcut icon" href="favicon.png" type="image/x-icon" />
  <style>
    body {
      font-size: 20px;
      /* 设置默认字体大小 */

    }

    /* thead{
      border-top: 1px solid #ccc; 
    } */
    .table td {
      border: none
    }

    .table th {
      border: none
    }

    .table tr {
      border: none
    }

    .table-container {
      overflow-x: auto;
      /* width:120%; */
      margin: 0 auto;
    }

    /* table {
      overflow-x: auto;
    } */
    .audio-container {
      display: flex;
      justify-content: center;
      align-items: center;
      border: none
    }

    /* .video-container {
      position: relative;
      width: 600px;
      margin: 0 auto;
      padding-bottom: 56.25%; /* 16:9宽高比，调整此值适配其他比例的视频 */
    /* overflow: hidden;
    }

    /* 视频元素的样式 */
    /* .video-container video {
      /* position: absolute; */
    /* top: 0;
      left: 0;
      width: 600px; */
    /* height: 100%; */

    video {
      width: 640px;
      /* 设置视频宽度 */
      height: 360px;
      /* 设置视频高度 */
    }

    hr {
      border-color: #767676;
      /* 可根据需要修改颜色值 */
      border-width: 1px;
      /* 可根据需要修改宽度值 */
    }

    @media(min-width:1200px) {
      .table-container {
        overflow-x: auto;
        width: 100%;
        margin: 0 auto;
      }
    }

    @media (max-width: 600px) {

      /* 在手机屏幕上应用以下样式 */
      body {
        font-size: 14px;
        /* 缩小字体大小 */
      }

      h1 {
        font-size: 22px;
        /* 缩小标题字体大小 */
      }

      h2 {
        font-size: 18px;
        /* 缩小标题字体大小 */
      }

      nav ul li {
        display: block;
        /* 列表项显示为块级元素，方便手机点击 */
      }

      .video-container {
        padding-bottom: 75%;
        /* 4:3宽高比，调整此值适配其他比例的视频 */
      }

      video {
        width: 400px;
        /* 设置视频宽度 */
        /* height: 360px; 设置视频高度 */
      }
    }
  </style>
  <title>MAGICITY4D</title>
</head>

<!-- <body rightmargin="150" leftmargin="150" topmargin="100" bottommargin="100" line-height:160%> -->
  <!-- <font size="5"> -->
<body>
  <div class="container">

    <header role="banner">

    </header>
    <main role="main">
      <article itemscope itemtype="https://schema.org/BlogPosting">
        <br></br>
        <h1 itemprop="headline" align="center">
          <font color="000093">MAGICITY4D: Controllable and Editable 4D City Scene Generation Using MLLM-Enhanced Procedural Content Generation</br>
          </font>
        </h1>
        <br></br>
        <!-- <p style="line-height:1" align="center"><b>
          <font color="061E61">Xu Zhang<sup>1</sup>, Hualong Yu<sup>1</sup>, Xiaohang Dong<sup>1</sup>, Jianye Wang<sup>1</sup>, Qicheng Li<sup>1,*</sup></font>
          </b></p>
        <p style="line-height:0.6" align="center">
          <font color="061E61"><sup>1</sup>College of Computer Science, Nankai University, Tianjin, China</font>
        </p>

        <p style="line-height:1;font-size:17px;" align="center">
          <font color="061E61"><sup>*</sup>Corresponding author</font>
        </p> -->
        <section itemprop="entry-text">
          <br>

      <div class="video-carousel-container">
        <div class="video-carousel-strip" id="videoStrip">
            </div>
        <div class="video-controls">
            <button onclick="moveCarousel(-1)">&#9664;</button>
            <button onclick="moveCarousel(1)">&#9654;</button>
        </div>
    </div>
    
    <script>
        // 视频数据源，可以根据需要添加或删除
        const videoData = [
            './video/video1.mp4',
            './video/video2.mp4',
            './video/video3.mp4',
            './video/video4.mp4',
            './video/video5.mp4',
            './video/video6.mp4',
        ];
    
        const videoStrip = document.getElementById('videoStrip');
        // --- 关键配置参数 ---
        const videoWidth = 600;        // 每个视频的固定宽度
        const videoGap = 30;           // 视频之间的间距
        const visiblePartWidth = 150;  // 左右各露出部分的宽度
        const transitionDuration = 500; // 动画持续时间（毫秒）
        // --- 关键配置结束 ---
    
        // 自动计算容器和视频项的宽度
        const containerWidth = videoWidth + (visiblePartWidth * 2) + (videoGap * 2);
        const itemFullWidth = videoWidth + videoGap;
    
        let currentVideoIndex = 1; // 初始索引从1开始，因为索引0是副本
        let isMoving = false;
    
        // 1. 创建视频元素和副本，并添加到DOM中
        function createVideoItems() {
            if (videoData.length <= 1) {
                console.error("视频数量不足，无法实现无缝循环。请添加更多视频。");
                return;
            }
    
            // 添加最后一个视频的副本到开头
            videoStrip.appendChild(createVideoElement(videoData[videoData.length - 1], 'clone'));
            // 添加所有真实视频
            videoData.forEach(src => videoStrip.appendChild(createVideoElement(src)));
            // 添加第一个视频的副本到结尾
            videoStrip.appendChild(createVideoElement(videoData[0], 'clone'));
    
            // 确保所有视频都自动播放
            document.querySelectorAll('.video-item').forEach(video => video.play());
        }
    
        function createVideoElement(src, className = '') {
            const video = document.createElement('video');
            video.className = `video-item ${className}`;
            video.controls = true;
            video.muted = true;
            video.loop = true;
            video.playsinline = true; // 移动端内联播放
            video.innerHTML = `<source src="${src}" type="video/mp4">`;
            return video;
        }
    
        // 2. 移动轮播图的核心函数
        function moveCarousel(direction) {
            if (isMoving) return;
            isMoving = true;
    
            videoStrip.style.transition = `transform ${transitionDuration}ms ease-in-out`;
            currentVideoIndex += direction;
    
            // 计算平移距离
            const offset = (currentVideoIndex * itemFullWidth) - (visiblePartWidth + videoGap);
            videoStrip.style.transform = `translateX(-${offset}px)`;
    
            // 在动画结束后进行瞬时重置
            setTimeout(() => {
                if (currentVideoIndex === videoData.length + 1 || currentVideoIndex === 0) {
                    videoStrip.style.transition = 'none';
    
                    if (currentVideoIndex === videoData.length + 1) {
                        currentVideoIndex = 1;
                    } else if (currentVideoIndex === 0) {
                        currentVideoIndex = videoData.length;
                    }
    
                    const resetOffset = (currentVideoIndex * itemFullWidth) - (visiblePartWidth + videoGap);
                    videoStrip.style.transform = `translateX(-${resetOffset}px)`;
                }
                isMoving = false;
            }, transitionDuration);
        }
    
        // 页面加载时执行
        window.onload = () => {
            // 在JS中设置容器的宽度，确保与计算值一致
            const videoContainer = document.querySelector('.video-carousel-container');
            videoContainer.style.width = `${containerWidth}px`;
            
            createVideoItems();
            // 初始位置，让第一个真实视频居中
            const initialOffset = (currentVideoIndex * itemFullWidth) - (visiblePartWidth + videoGap);
            videoStrip.style.transform = `translateX(-${initialOffset}px)`;
        };
    </script>
    
    <style>
        /* 容器：限制可见区域 */
        .video-carousel-container {
            position: relative;
            height: auto;
            overflow: hidden;
            margin: 0 auto;
        }
    
        /* 视频条带：所有视频的容器 */
        .video-carousel-strip {
            display: flex;
            /* 动画过渡时间由 JS 动态控制 */
        }
    
        /* 每个视频元素 */
        .video-item {
            width: 600px;
            height: auto;
            flex-shrink: 0;
            margin-right: 30px;
        }
    
        /* 切换按钮 */
        .video-controls {
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            transform: translateY(-50%);
            display: flex;
            justify-content: space-between;
            z-index: 10;
            padding: 0 10px;
        }
    
        .video-controls button {
            background: rgba(0, 0, 0, 0.5);
            border: none;
            color: white;
            font-size: 2em;
            cursor: pointer;
            padding: 10px;
            border-radius: 50%;
        }
    
        .video-controls button:hover {
            background: rgba(0, 0, 0, 0.8);
        }
    </style>


    <br>

          <h2 style="text-align: center;" id="abstract">
            <font color="000093">Abstract</font>
        </h2>
          <p style="text-align: justify;">
            <font color="061E61">
              In recent years, 3D city scene generation has made significant progress. However, controllable and editable 4D city scene generation remains a largely unsolved challenge. The core difficulty lies in effectively incorporating temporal dynamics. It also requires precise control over scene content and higher system coordination. To address these challenges, we propose MagiCity4D, a multimodal 4D city scene generation framework. By deeply integrating Multimodal Large Language Models (MLLMs) and Procedural Content Generation (PCG), our framework enables both controllable 4D city scene generation and real-time, fine-grained editing without additional training. The experimental results show that MagiCity4D outperforms existing methods in overall performance, demonstrating its potential for advanced city scene generation. Our project page: https://erxucomeon.github.io/MagiCity.</font>
          </p>
           
          <br>

          <figure>
            <p align="center"><img src="./img/main.png" width="90%" class="center" /></p>
            <figcaption style="display: flex; justify-content: center;">
              <p style="text-align: justify;">
                  <font color="061E61"><b>Fig. 1:</b> Pipeline of MagiCity4D. The MagiCity4D pipeline is divided into two stages: Stage 1 (top) manages open-source asset generation and integration, while Stage 2 (bottom) utilizes the outputs from Stage 1 to generate and edit the 4D city scenes.
              </p>
          </figcaption>
          </figure>
          <br>
          <figure>
            <p align="center"><img src="./img/compare.png" width="90%" class="center" /></p>
            <figcaption style="display: flex; justify-content: center;">
              <p style="text-align: justify;">
                  <font color="061E61"><b>Fig. 2:</b> Quality comparison.
              </p>
          </figcaption>
          </figure>
          <br>
          <figure>
            <p align="center"><img src="./img/consistency.png" width="90%" class="center" /></p>
            <figcaption style="display: flex; justify-content: center;">
              <p style="text-align: justify;">
                  <font color="061E61"><b>Fig. 3:</b> Spatial consistency of city Layout.
              </p>
          </figcaption>
          </figure>
          <br>
          <figure>
            <p align="center"><img src="./img/generation.png" width="90%" class="center" /></p>
            <figcaption style="display: flex; justify-content: center;">
              <p style="text-align: justify;">
                  <font color="061E61"><b>Fig. 4:</b> Visualization of generated City scenes.
              </p>
          </figcaption>
          </figure>

          <br>
          <figure>
            <p align="center"><img src="./img/editing.png" width="90%" class="center" /></p>
            <figcaption style="display: flex; justify-content: center;">
              <p style="text-align: justify;">
                  <font color="061E61"><b>Fig. 5:</b> City scene editing.
              </p>
          </figcaption>
          </figure>

          <p style="text-align: justify;">
            <font color="061E61">
              Fig. 2 shows the comparison of the generation quality of each method, Fig. 3 shows the visual comparison between the layout sketch (left) and the generated city layout (right), demonstrating our method's high degree of spatial consistency. Fig. 4 shows the visualization of the city scenes generated by MagiCity4D. Additionally, Fig. 5 shows MagiCity4D's powerful ability to edit city scenes.</font>
          </p>


        </section>
      </article>
    </main>

  </div>

  <script>
    (function (i, s, o, g, r, a, m) {
      i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
        (i[r].q = i[r].q || []).push(arguments)
      }, i[r].l = 1 * new Date(); a = s.createElement(o),
        m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
    })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');
    ga('create', 'UA-139981676-1', 'auto');
    ga('send', 'pageview');
  </script>

  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>



  <script type="text/x-mathjax-config">
     MathJax.Hub.Config({
         HTML: ["input/TeX","output/HTML-CSS"],
         TeX: {
                Macros: {
                         bm: ["\\boldsymbol{#1}", 1],
                         argmax: ["\\mathop{\\rm arg\\,max}\\limits"],
                         argmin: ["\\mathop{\\rm arg\\,min}\\limits"]},
                extensions: ["AMSmath.js","AMSsymbols.js"],
                equationNumbers: { autoNumber: "AMS" } },
         extensions: ["tex2jax.js"],
         jax: ["input/TeX","output/HTML-CSS"],
         tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                    displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
                    processEscapes: true },
         "HTML-CSS": { availableFonts: ["TeX"],
                       linebreaks: { automatic: true } }
     });
 </script>

  <script type="text/x-mathjax-config">
     MathJax.Hub.Config({
       tex2jax: {
         skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
       }
     });
 </script>

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
  <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"
    integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo"
    crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/popper.js@1.14.7/dist/umd/popper.min.js"
    integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1"
    crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.3.1/dist/js/bootstrap.min.js"
    integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM"
    crossorigin="anonymous"></script>
</body>

</html>